package core.simulator

import core.routing.Route
import core.routing.Topology
import core.simulator.notifications.Notifier
import core.simulator.notifications.EndNotification
import core.simulator.notifications.StartNotification
import core.simulator.notifications.ThresholdReachedNotification
import java.util.*

/**
 * Created on 23-07-2017
 *
 * @author David Fialho
 *
 * The [Simulator] is the starting point to run simulations. It provides the [simulate] methods,
 * which are supported way to start running a simulation. They setup the simulation according to
 * the given parameters and, then run the simulation loop which, more or less, consists of taking
 * scheduled events from the [scheduler] and processing them.
 *
 * The [Simulator] also holds the [scheduler] and [messageDelayGenerator] being used on the
 * simulations. Simulation events are scheduled using the [scheduler] specified by the [Simulator].
 * The same is true for message delays: these are generated by the [messageDelayGenerator].
 *
 */
object Simulator {

    /**
     * Holds the scheduler used in the simulations.
     */
    var scheduler = Scheduler()

    /**
     * Generator used to generate message delays. By default, it uses a [NoDelayGenerator],
     * consider [RandomDelayGenerator] as an alternative to simulate different behavior.
     */
    var messageDelayGenerator: DelayGenerator = NoDelayGenerator

    /**
     * Resets the simulators's configurations to its defaults.
     */
    fun resetToDefaults() {
        scheduler = Scheduler()
        messageDelayGenerator = NoDelayGenerator
    }

    /**
     * Runs a simulation with multiple [advertisements] over a [topology]. The simulation is
     * initiated by scheduling the [advertisements]. Afterwards, an event loop is run,
     * taking each event from the [scheduler] and processing it. The simulation ends once there
     * are no more simulation events in the [scheduler] or the [threshold] is reached. If a
     * [threshold] value is not specified, then the simulation will run until the scheduler has
     * no more events to process.
     *
     * During the simulation the notifiers (@see [Notifier]) may send some notifications,
     * which provide information about routing events and the progress of the simulation.
     *
     * Warning: before running the simulation, the scheduler is reset!!
     *
     * @return true if the simulation ended before the [threshold] is reached or false if otherwise.
     * @throws IllegalArgumentException if [advertisements] includes zero advertisements
     */
    @Throws(IllegalArgumentException::class)
    fun <R : Route> simulate(topology: Topology<*>, advertisements: List<Advertisement<R>>,
                             threshold: Time = Int.MAX_VALUE): Boolean {

        if (advertisements.isEmpty()) {
            throw IllegalArgumentException("a simulation requires at least one advertisement")
        }

        // Ensure the scheduler is completely clean before starting the simulation
        scheduler.reset()

        Notifier.notify(StartNotification(messageDelayGenerator.seed, topology))

        // Schedule advertisements specified in the strategy
        for (advertisement in advertisements) {
            scheduler.schedule(advertisement)
        }

        // Flag that will indicate whether or not the simulation finished before the threshold
        // was reached
        var terminatedBeforeThreshold = true

        while (scheduler.hasEvents()) {
            val event = scheduler.nextEvent()

            // Check if the threshold was reached:
            // This verification needs to be performed after obtaining the next event because the
            // scheduler's time is updated when performing that action
            if (currentTime() >= threshold) {
                Notifier.notify(ThresholdReachedNotification(threshold))
                terminatedBeforeThreshold = false
                break
            }

            event.processIt()
        }

        // Notify listeners the simulation ended
        Notifier.notify(EndNotification(topology))

        return terminatedBeforeThreshold
    }

    /**
     * Runs a simulation with multiple [advertisement] over a [topology]. The simulation is
     * initiated by scheduling the [advertisement]. Afterwards, an event loop is run,
     * taking each event from the [scheduler] and processing it. The simulation ends once there
     * are no more simulation events in the [scheduler] or the [threshold] is reached. If a
     * [threshold] value is not specified, then the simulation will run until the scheduler has
     * no more events to process.
     *
     * During the simulation the notifiers (@see [Notifier]) may send some notifications,
     * which provide information about routing events and the progress of the simulation.
     *
     * Warning: before running the simulation, the scheduler is reset!!
     *
     * @return true if the simulation ended before the [threshold] is reached or false if otherwise.
     */
    fun <R : Route> simulate(topology: Topology<R>, advertisement: Advertisement<R>,
                             threshold: Time = Int.MAX_VALUE): Boolean {
        return simulate(topology, listOf(advertisement), threshold)
    }

    /**
     * Returns the simulator version.
     * It obtains the version from the resource where the simulator's version is defined.
     */
    fun version(): String {

        javaClass.getResourceAsStream("/version.properties").use {
            val properties = Properties()
            properties.load(it)
            return properties.getProperty("application.version")
        }
    }

}

/**
 * Schedules an advertisement event.
 */
private fun <R : Route> Scheduler.schedule(advertisement: Advertisement<R>) {
    schedule(AdvertiseEvent(advertisement.advertiser, advertisement.route), advertisement.time)
}

/**
 * Cleaner way to access the simulation time.
 */
@Suppress("NOTHING_TO_INLINE")
inline fun currentTime(): Time = Simulator.scheduler.time